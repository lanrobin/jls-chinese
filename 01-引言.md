Java 语言规范
===
第一章 引言
---
Java 编程语言是一种通用的、并发的、基于类的、面向对象的语言。它旨在使许多编程者可以简单、流畅地使用此语言。Java 编程语言与 C、C++ 相关，但以不同的方式组织，省略了 C、C++ 的一部分方面，包含了一些其它语言的想法。

Java 编程语言是强、静态类型的。此规范明确区分了那些可以且必须在编译时检测出来的编译时错误和那些在运行时发生的错误。编译时间通常由将程序翻译成机器独立的字节码表示组成。运行时活动包括加载和链接需要执行程序的类、可选的机器码生成和程序动态优化，以及实际程序执行。

Java 编程语言是一种相对高级的语言，通过该语言无法得知机器表示的详情。它包括自动存储管理，通常使用 GC，以避免显式释放的安全问题（像在 C 中的 free 或 C++ 中的 delete 那样）。高性能的 GC 实现可以实现有界的暂停，以支持系统编程和实时应用程序。该语言不包含任何不安全的结构，如不带有索引检查的数组访问，因为不安全的结构会导致程序出现意料之外的行为。

Java编程语言通常编译成字节码指令集和 The Java Virtual Machine Specification, Java SE 14 Edition 中定义的二进制格式。
<br>
<br>

### 1.1 规范的组织结构
Chapter 2 描述了用于表示语言的词法和语法的语法和表示法。

Chapter 3 描述了Java编程语言的词法结构，其基于 C 和 C++。语言用 Unicode 字符集写。它支持在仅支持 ASCII 的系统上写 Unicode 字符。

Chapter 4 描述了类型、值和变量。类型分为原始类型和引用类型。

原始类型在所有机器和实现上都定义为相同的，并且是各种大小的，二进制补码整数，单、双精度 IEEE 754 标准浮点数字，布尔类型，Unicode 字符  char 类型。原始类型的值不共享状态。

引用类型是类类型、接口类型和数组类型。引用类型由动态地创建类或数组的实例来实现。每个对象的多个引用可以共存。所有对象（包括数组）支持类 Object 的方法，类 Object 是类层次结构的（单个）根。预定义的 String 类支持 Unicode 字符的字符串。存在将原始类型包装到对象中的类。在许多情况下，包装和解包装由编译器自动执行（这种情况下，包装叫做装箱，解包装叫做拆箱）。类和接口可以声明为泛型的，即，它们被其它引用类型参数化。然后可以用特定的类型参数调用此类声明。

变量是类型化存储位置。原始类型的变量持有该精确原始类型的值。类类型的变量可以持有一个 null 引用，或者一个引用，其是到一个类型是该类类型或该类类型的任何子类的对象的引用。接口类型的变量可以持有一个 null 引用或一个实现该接口的任何类的实例的引用。数组类型的变量可以持有一个 null 引用或一个到一个数组的引用。类类型 Object 的变量可以持有一个 null 引用或一个到任何对象的引用，无论该对象是类实例还是数组。

Chapter 5 描述了转换和数字提升。转换会改变编译时类型，有时还会改变表达式的值。这些转换包括原始类型和引用类型之间的装箱和拆箱。数字提升用于数值运算符的操作数转换为可执行操作的通用类型。语言在这方面没有漏洞；引用类型的转换需要运行时检查，以确保类型安全。

Chapter 6 描述了声明和名字，以及如何确定名字表示什么。语言不要求类型或它们的成员在它们被使用之前声明。声明顺序仅对局部变量、局部类以及类或接口中的字段的初始化器的顺序重要。

Java 编程语言提供了名字作用域的控制，并支持对包、类和接口的成员进行外部访问的限制。这有助于在编写大型程序时区分其用户和扩展的类型的实现。这描述了可用于编写可读程序的推荐的命名约定。

Chapter 7 描述了一个程序结构，它被组织成类似于语言的模块的包。包的成员是类、接口和子包。包分割成编译单元。编译单元包含类型声明，并且可以导入来自其它包的类型，以提供它们的短名称。包在层次命名空间中具有名称，并且互联网域名系统通常可以用于形成唯一包名。

Chapter 8 描述了类。类的成员是类、接口、字段（变量）和方法。每个类变量在一个类中存在一个。类方法在不引用一个特定对象的情况下操作。实例变量在类的实例的对象中动态地创建。实例方法在类的实例上调用；在它们执行期间，此类实例成为当前对象 this，支持面向对象编程风格。

类支持单实现继承，其中每个类的实现都是从单个超类派生的，最终来自类 Object。类类型的变量可以引用一个该类或该类的任何子类的实例，从而允许新类型与现存的方法一起多态地使用。

类支持带有 synchronized 方法的并发编程。方法声明可从执行过程中抛出的已检查异常，这允许进行检查以确保处理异常情况。对象可以声明一个 finalize 方法，其将会在对象被 GC 丢弃之前被调用，从而允许对象清除状态。

为了简单起见，语言既没有声明区别类实现的“头”，也没有区分类型和类层次结构。

一个特殊形式的类，枚举，支持一组有限的值的定义以及以一种类型安全的方式操作它们。不像其它语言中的列举，枚举是对象，并可以拥有自己的方法。

Chapter 9 描述了接口类型，其声明了一组抽象方法、成员类型和常量。其它无关的类可以实现相同的接口类型。接口类型的变量可以包含到实现该接口的任何对象的一个引用。支持多接口继承。

注解是用于注解声明的专用接口。此类注解不得以任何方式影响程序在 Java 编程语言中的语义。但是，它们向各种工具提供了有用的输入。

Chapter 10 描述了数组。数组访问包括边界检查。数组是动态地创建的对象，并可以被分配给 Object 类型的变量。语言支持数组的数组，而不是多维数组。

Chapter 11 描述了异常，它们是非恢复的，并与语言的语义和并发机制完全集成。有三种异常：已检查异常、运行时异常和错误。编译器通过要求方法或构造器仅在方法或构造器声明它时才会导致已检查异常，从而确保已检查异常被正确地处理。这提供了对异常处理器存在的编译期检查，并在很大程度上有助于编程。大多数用户定义的异常应是已检查异常。程序中由 Java 虚拟机检测到的无效操作会导致运行时异常，例如 NullPointerException。错误是由 Java 虚拟机检测到的故障引起的，例如 OutOfMemoryError。大多数简单程序不尝试处理错误。

Chapter 12 描述了程序执行期间发生的活动。程序通常存储为表示被编译的类和接口的二进制文件。这些二进制文件可被加载进 Java 虚拟机中，链接到其它类和接口，并初始化。

初始化之后，类方法和类变量可被使用。一些类可能被实例化，以创建该类类型的新对象。类实例的对象也包括该类的每个子类的实例，并且对象创建涉及这些父类实例的递归创建。

当不再引用一个对象时，它可能会被 GC 回收。如果对象声明了终结器，在回收对象之前执行终结器，以给该对象最后一次清除那些还未释放的资源的机会。当不再需要一个类时，它可能会被卸载。

Chapter 13 描述了二进制兼容性，指定了类型改变对那些使用该改变的类型但未重新编译的其它类型的影响。这些考虑对那些在一系列连续版本中常常通过互联网广泛地分发类型的开发者来说是很有意义的。无论类型何时改变，好的程序开发环境会自动重新编译依赖代码，所以大多数编程者不需要关心这些细节。

Chapter 14 描述了块和语句，其是基于 C 和 C++。语言中没有 goto 语句，但包含带标签的 break 和 continue 语句。不像 C，Java 编程语言在控制流语句中要求布尔（或 Boolean）表达式，并不将类型隐式转换为布尔（除了通过拆箱以外），希望在编译时捕获更多错误。synchronized 语句提供了基本的对象级管程锁定。try 语句可以包含 catch 和 finally 子句，以防止非本地控制转移。

Chapter 15 描述了表达式。此文档完整指定了表达式计算的（明显的）顺序，以提高确定性和可移植性。重载方法和构造器是在编译时通过从那些适用的方法或构造器中选择最具体的方法或构造器来解析的。

Chapter 16 描述了语言确保局部变量使用前明确设置的精确方法。虽然所有其它变量会被自动初始化为默认值，但Java程序语言不会自动初始化局部变量，以避免掩盖程序错误。

Chapter 17 描述了线程和锁的语义，其是基于基于管程的并发，最初是用 Mesa 编程语言引入的。Java 编程语言指定了一个支持高性能实现的共享内存的多处理器的内存模型。

Chapter 18 描述了多种类型推断算法，以测试泛型方法的适用性和推断泛型方法调用中的类型。

Chapter 19 给出了语言的语法句法。
<br>
<br>

### 1.2示例程序（省略）
<br>

### 1.3 符号

在本规范中，我们引用了从 Java SE 平台 API 中抽取的类和接口。无论何时我们使用一个标识符 N 来引用类或接口（除了那些在示例中声明的），旨在引用包 java.lang 中的名为 N 的类或接口。我们使用来自包 java.lang 以外的类或接口的规范名（6.7）。

旨在澄清本规范的非正式的信息以更小的缩进文本方式给出。

Java 编程语言的类型系统偶尔依赖于一种替代的概念。概念 [F1:=T1,...,Fn:=Tn] 表示用 Ti 来表示 Fi 的替代，对于 1 ≤ i ≤ n 。
<br>
<br>

### 1.4 预定义的类和接口的关系

如上面所述，此规范经常引用 Java SE 平台 API 的类。特别地，一些类与 Java 编程语言有特殊关系。示例包括类如 Object、Class、ClassLoader、String、Thread 以及包 java.lang.reflect 中的类和接口等。此规范约束此类类和接口的行为，但不为它们提供完整的规范。读者应引用 Java SE 平台 API 文档。

因此，此规范不描述任何反射详情。许多语言学构造在核心反射 API（java.lang.reflect）和语言模型 API（javax.lang.model）上有相似的地方，但这通常不在这讨论。例如，当我们列举可以创建对象的方式时，我们通常不包括使用核心反射 API 完成这个的方式。即使没有在文本中提到它们，读者应该知道这些额外的机制。
<br>
<br>

### 1.5 实验性的功能
实验性的功能是Java编程语言的一项新的，完全定义并且实现了，但还没有正式布的功能。它在只在给定版本的Java SE平台上发布以获取开发人员基于实际使用情况的反馈；这能更好测试是否能在Java SE平台的新版本做为正式的功能提供。

实验性新功能的实现默认情况下必须在Java语言编译时和运行时都禁用，除非用户指定开户该实验性功能。

给定版本的Java SE Platform定义的实验性的功能的文档是独立提供的，一般都以The Java® Language Specification的增量来提供，可以在https://docs.oracle.com/javase/specs/找到。

Java SE 14用Java编程语言定义了三种预览功能：

1. 用于instanceof的模式匹配；
2. 记录类型;
3. 和文本块。

Oracle Web上提供了指定这些预览功能的独立文档。托管Java®语言规范的站点：https://docs.oracle.com/javase/specs/.

实验性的功能可能与Java SE Platform API的相关联。比如相关的API在包java.lang或java.lang.annotation中，如果程序没有（直接或间接）引用这些API，则无法使用实验性的功能。

如果禁用了实验性的功能，则在会在编译时产生错误。

如果启用了实验性的功能，则Java编译器必须产生实验性的警告：不管你是直接还是间接使用（重写、调用或者引用了名称）了这些API，除非：
* 使用在声明中，该声明本身是必不可少的API元素；要么
* 使用在声明中，以禁止预览警告（第9.6.4.5节）；要么
* 使用出现的声明和基本API的声明元素都在同一个最外层类中；要么
* 用途在导入声明中，该声明用于导入基本API元素。
  
Java SE 14包含以下基本API元素：
* 对于实验性的功能Records：Record类；和在枚举java.lang.annotation.ElementType中的常量RECORD_COMPONENT。
* 对于实验性的功能Text Blocks：在java.lang.String类中的方法stripIndent
和translateEscapes。
### 1.6 反馈（省略）
<br>

### 1.7 参考（省略）
